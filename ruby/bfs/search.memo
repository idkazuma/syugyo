adjacent = ((0, 1, 1, 0, 0, 0, 0),   # A 
        (1, 0, 1, 1, 0, 0, 0),   # B
        (1, 1, 0, 0, 1, 0, 0),   # C
        (0, 1, 0, 0, 1, 1, 0),   # D
        (0, 0, 1, 1, 0, 0, 1),   # E
        (0, 0, 0, 1, 0, 0, 0),   # F
        (0, 0, 0, 0, 1, 0, 0))   # G

    A => (B, C)
    B => (A, C, D) 
    C => (A, B, E)
    D => (B, E, F)
    E => (C, D, G)
    F => (D)
G => (E)


    def search(goal, path):
        search の第 1 引数がゴール、第 2 引数が経路を表すリストです。リストの最後尾の要素が現在地点の頂点になります。search は現在地点に隣接している頂点を一つ選び、経路を進めていきます。A から Gまでの経路を求めるには、次のように呼び出します。

# A から G までの経路を求めるK *)
        search(6, [0])
    search は出発点 A をリストにセットし、A に接続されている頂点を選びます。隣接リストから順番に選ぶことにすると、次の頂点は B となります。B へ進むためには、次のように search を再帰呼び出しします。


    search(6, [0, 1]);

    def search(goal, path):
        n = path[len(path) - 1]
        if n == goal:
        print path
        else:
        for x in adjacent[n]:
        if x not in path:
    path.append(x)
    search(goal, path)
        path.pop()
        関数 search を見てください。最初に path の最後尾の要素を取り出して変数 n にセットします。これが現在地点になります。そして、n がゴール地点 goal かチェックします。これが再帰呼び出しの停止条件になります。ゴールに到達したら print で経路 path を表示します。

        ここで探索を終了することもできますが、バックトラックすることで全ての経路を見つけることができます。パズルを解く場合、解の総数を求めることが多いので、全ての解をもれなく探索する必要があります。バックトラックを使えば、このような要求も満たすことができます。

        ゴールしていない場合は、隣接リストから次の頂点を選びます。隣接リストから順番に頂点を取り出して、変数 x にセットします。このとき、経路に含まれている頂点を選んではいけません。そうしないと、同じ道をぐるぐると回る巡回経路が発生し、ゴールまでたどり着くことができなくなります。not in 演算子で path 内に頂点 x がないことを確認します。それから、append で path に x を追加して search を再帰呼び出しします。再帰呼び出しのあと、pop で x を削除することをお忘れなく。

        実行結果は次のようになります。

        [0, 1, 2, 4, 6]
        [0, 1, 3, 4, 6]
        [0, 2, 1, 3, 4, 6]
        [0, 2, 4, 6]


